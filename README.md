Briefly summarize the requirements and goals of the application you developed. What user needs was this application designed to address?
What did you do particularly well in developing this application?
Compare and contrast the Console and WPF application designs. What screens and features were necessary to support user needs and produce a user-centered UI for the app? How did your UI designs keep users in mind? Why were your designs successful?
How did you approach the process of debugging and coding your application? What techniques or strategies did you use? How could you use those techniques or strategies in the future?
Where did you have to be innovative to overcome a challenge in the full application development process?

The application was designed to assist students in signing up for classes. I worked with the existing code to fix bugs, improve functionality, and create new features.

Console applications use a text-based interface for quick tasks, while WPF applications offer a rich graphical interface with complex interactions. Console apps are lightweight and easy to develop, whereas WPF apps require knowledge of XAML and follow the MVVM design pattern. The choice between the two depends on the project’s needs and the desired user experience. 

It was important to create a user-friendly screen to help users understand how to operate the program more easily than with a console application. The graphical interface also aligns better with users' expectations. By providing a drop-down list of available classes, the application enables users to search for their desired courses conveniently. Additionally, the program keeps track of the number of courses a student is signed up for, ensuring they do not exceed the nine-hour maximum. It also prevents students from enrolling in the same course more than once. 

The application’s success can be attributed to its consideration of potential user mistakes during the signup process. Effective debugging techniques, such as using breakpoints and step-through debugging, allowed me to inspect variable values during execution. These strategies significantly improved problem identification and enhanced code quality for future projects. Throughout this process, I had to be innovative as I was venturing into new territory. I was continually learning and refining my approach.
